#!/usr/bin/env bun
/**
 * Generate typed ambient module declarations for MDX prompt components.
 *
 * Uses remark-mdx to parse each MDX file into an AST, then walks
 * expression nodes to extract `props.X` references. Infers required
 * vs optional from guard patterns in the JS expressions, and writes
 * src/mdx.d.ts so that `tsc --noEmit` catches prop mismatches.
 *
 * Usage: bun scripts/gen-mdx-types.ts
 */

import { readdirSync, readFileSync, writeFileSync } from "node:fs";
import { join, basename } from "node:path";
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkMdx from "remark-mdx";
import { visit } from "unist-util-visit";

const ROOT = join(import.meta.dir, "..");
const PROMPTS_DIR = join(ROOT, "src/prompts");
const OUTPUT = join(ROOT, "src/mdx.d.ts");

const processor = unified().use(remarkParse).use(remarkMdx);

const PROPS_RE = /(?<![.\w])props\.(\w+)/g;

const GUARD_PATTERNS = (name: string) => [
  new RegExp(`props\\.${name}\\s*&&`),
  new RegExp(`props\\.${name}\\s*\\?\\s*[^.?]`),
  new RegExp(`props\\.${name}\\s*\\?\\?`),
  new RegExp(`props\\.${name}\\s*\\|\\|`),
  new RegExp(`Array\\.isArray\\(props\\.${name}\\)`),
];

interface PropInfo {
  name: string;
  required: boolean;
}

/**
 * Parse MDX into an AST via remark-mdx, walk expression nodes,
 * and extract all `props.X` references with optionality info.
 */
function extractProps(mdxSource: string): PropInfo[] {
  const tree = processor.parse(mdxSource);

  // Collect raw JS expression strings from AST nodes
  const expressions: string[] = [];

  visit(tree, (node: any) => {
    // Inline and block expressions: {props.X}, {props.X && ...}
    if (node.type === "mdxTextExpression" || node.type === "mdxFlowExpression") {
      expressions.push(node.value);
    }

    // JSX attribute expressions: <Comp title={props.X} />
    if (
      node.type === "mdxJsxTextElement" ||
      node.type === "mdxJsxFlowElement"
    ) {
      for (const attr of node.attributes ?? []) {
        if (
          attr.type === "mdxJsxAttribute" &&
          attr.value &&
          typeof attr.value === "object" &&
          attr.value.value
        ) {
          expressions.push(attr.value.value);
        }
        if (attr.type === "mdxJsxExpressionAttribute") {
          expressions.push(attr.value);
        }
      }
    }

    // Code fences: MDX doesn't interpolate {props.X} inside ```,
    // but prompts reference them as template values. Scan these too
    // so the generated types include all props the component needs.
    if (node.type === "code" && node.value) {
      expressions.push(node.value);
    }

    // Inline code: `{props.findingsFile}` — same reasoning
    if (node.type === "inlineCode" && node.value) {
      expressions.push(node.value);
    }
  });

  // Extract prop names + optionality from collected expressions
  const propUsages = new Map<string, { guarded: boolean; direct: boolean }>();

  for (const expr of expressions) {
    let match;
    PROPS_RE.lastIndex = 0;
    while ((match = PROPS_RE.exec(expr)) !== null) {
      const name = match[1];
      if (!propUsages.has(name)) {
        propUsages.set(name, { guarded: false, direct: false });
      }
    }

    for (const [name, usage] of propUsages) {
      if (GUARD_PATTERNS(name).some((p) => p.test(expr))) {
        usage.guarded = true;
      }
      // Direct interpolation: expression is just `props.X` (no guard)
      if (new RegExp(`^\\s*props\\.${name}\\s*$`).test(expr)) {
        usage.direct = true;
      }
    }
  }

  return [...propUsages.entries()]
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([name, usage]) => ({
      name,
      required: usage.direct || !usage.guarded,
    }));
}

function generateModuleDecl(filename: string, props: PropInfo[]): string {
  const name = basename(filename, ".mdx");
  const lines = [
    `declare module "*/prompts/${filename}" {`,
    `  interface ${name}PromptProps {`,
  ];

  for (const prop of props) {
    lines.push(`    ${prop.name}${prop.required ? "" : "?"}: any;`);
  }

  lines.push(`  }`);
  lines.push(
    `  const Component: import("react").FC<${name}PromptProps>;`,
  );
  lines.push(`  export default Component;`);
  lines.push(`}`);

  return lines.join("\n");
}

// --- Main ---

const mdxFiles = readdirSync(PROMPTS_DIR)
  .filter((f) => f.endsWith(".mdx"))
  .sort();

if (mdxFiles.length === 0) {
  console.error("No .mdx files found in", PROMPTS_DIR);
  process.exit(1);
}

const header = [
  "// AUTO-GENERATED by scripts/gen-mdx-types.ts — DO NOT EDIT",
  "// Regenerate: bun scripts/gen-mdx-types.ts",
  "//",
  `// Typed declarations for ${mdxFiles.length} MDX prompt files.`,
  "// Props extracted from remark-mdx AST expression nodes,",
  "// so `tsc --noEmit` catches wrong names, missing props, and extras.",
  "",
].join("\n");

const modules = mdxFiles.map((file) => {
  const content = readFileSync(join(PROMPTS_DIR, file), "utf-8");
  return generateModuleDecl(file, extractProps(content));
});

writeFileSync(OUTPUT, header + "\n" + modules.join("\n\n") + "\n");

// Summary
console.log(`Generated ${OUTPUT}`);
for (const file of mdxFiles) {
  const content = readFileSync(join(PROMPTS_DIR, file), "utf-8");
  const props = extractProps(content);
  const req = props.filter((p) => p.required).length;
  const opt = props.filter((p) => !p.required).length;
  console.log(`  ${file}: ${req} required, ${opt} optional`);
}
