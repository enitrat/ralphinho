IMPLEMENTATION PHASE — Unit: {props.unitId}

Title: {props.unitName}
Category: {props.unitCategory}

## Context

Read the plan file: {props.planFilePath}
Read the context file: {props.contextFilePath}

Implementation steps from plan:
{props.implementationSteps ? props.implementationSteps.map((s, i) => `${i + 1}. ${s}`).join('\n') : 'See plan file'}

{props.previousImplementation ? `\nPrevious implementation attempt:\nWhat was done: ${props.previousImplementation.whatWasDone}\nNext steps: ${props.previousImplementation.nextSteps ?? 'None specified'}` : ''}
{props.evictionContext ? `\nMerge queue eviction context from prior landing attempt (address this explicitly):\n${props.evictionContext}` : ''}

{props.reviewFeedback ? `\nReview feedback to address:\n${props.reviewFeedback}` : ''}

{props.failingTests ? `\nFIX THESE FAILING TESTS FIRST:\n${props.failingTests}` : ''}

{props.acceptanceCriteria && props.acceptanceCriteria.length > 0 ? `\n## Acceptance Criteria\n${props.acceptanceCriteria.map((a, i) => `${i + 1}. ${a}`).join('\n')}` : ''}

{props.depSummaries && props.depSummaries.length > 0 ? `\n## Dependency Context\nThese units completed before yours and their changes are on main:\n${props.depSummaries.map(d => `### ${d.id}\n${d.whatWasDone}\nFiles created: ${d.filesCreated.length > 0 ? d.filesCreated.join(', ') : 'none'}\nFiles modified: ${d.filesModified.length > 0 ? d.filesModified.join(', ') : 'none'}`).join('\n\n')}` : ''}

## Implementation Approach

Assess whether TDD applies to this unit. **Not all work needs new tests — don't write tests that test nothing meaningful.**

**TDD applies** when the ticket changes observable behavior:
- New features, public API surface, or code paths
- Bug fixes (test reproduces the bug first)
- Changed inputs, outputs, or error handling

**TDD does not apply** when the work is mechanical:
- Dead code removal, unused exports, deprecated aliases
- Renaming, moving, reorganizing without behavior change
- Mechanical refactoring (extract function, change visibility)
- Work where the compiler already enforces correctness

### When TDD Applies — Red → Green → Refactor

**Step 1: Write Failing Tests FIRST**

{props.testWritingGuidance && props.testWritingGuidance.length > 0
  ? props.testWritingGuidance.map(g => `${g}`).join('\n\n')
  : '- Write tests for happy paths AND error paths\n- Run test command to confirm tests FAIL (red phase)'}

**Step 2: Write Minimal Implementation (Green Phase)**

- Write the SMALLEST amount of code to make failing tests pass
{props.implementationGuidance && props.implementationGuidance.length > 0
  ? props.implementationGuidance.map(g => `- ${g}`).join('\n')
  : '- Follow project architectural patterns'}

**Step 3: Refactor**

- Clean up while keeping tests green
- Extract shared logic, improve naming
{props.formatterCommands && props.formatterCommands.length > 0
  ? `- Run formatters: ${props.formatterCommands.join(', ')}`
  : '- Run formatters'}

### When TDD Does Not Apply

1. Make the changes described in the plan
2. Run typecheck — no new type errors
{props.verifyCommands && props.verifyCommands.length > 0 ? props.verifyCommands.map(c => `- Run \`${c}\` — existing tests must still pass`).join('\n') : '- Run existing tests — all suites must still pass'}
{props.formatterCommands && props.formatterCommands.length > 0 ? `- Run formatters: ${props.formatterCommands.join(', ')}` : '- Run formatters'}

### Verify (both paths)

{props.verifyCommands && props.verifyCommands.length > 0
  ? props.verifyCommands.map(c => `- Run \`${c}\``).join('\n')
  : '- Run all test suites to verify'}

## Architecture Rules

{props.architectureRules && props.architectureRules.length > 0
  ? props.architectureRules.map(r => `- ${r}`).join('\n')
  : '- Follow the architectural patterns defined in the specs'}

## JJ COMMIT — MANDATORY (DO NOT SKIP)

You MUST commit and push your changes to the ticket branch before finishing. Uncommitted work is lost work.

1. {`jj describe -m "${props.commitPrefix || "EMOJI"} type(scope): description"`} — describe your changes with a meaningful message.
2. `jj new` — create a new change for the next logical step. Repeat describe+new for each atomic change.
3. {`jj bookmark set ${props.branchPrefix || "unit/"}${props.unitId} -r @`}
4. {`jj git push --bookmark ${props.branchPrefix || "unit/"}${props.unitId}`}

{props.emojiPrefixes ? `Emoji prefixes: ${props.emojiPrefixes}` : 'Use conventional commit prefixes'}

**If you do not commit and push to the ticket branch, your work does not count. This is non-negotiable.**
