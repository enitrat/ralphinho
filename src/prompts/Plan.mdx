PLANNING PHASE ‚Äî Unit: {props.unitId}

Title: {props.unitName}
Description: {props.unitDescription}
Category: {props.unitCategory}
Acceptance Criteria:
{(Array.isArray(props.acceptanceCriteria) ? props.acceptanceCriteria : []).map((c, i) => `${i + 1}. ${c}`).join('\n')}

## Research Context

Read the context file first: {props.contextFilePath}

{props.researchSummary ? `Research summary: ${props.researchSummary}` : ''}
{props.evictionContext ? `\nPrevious merge-queue eviction context (must be addressed in this plan):\n${props.evictionContext}` : ''}

## Your Task

Create a detailed implementation plan. First, assess whether this work changes observable behavior or is mechanical/housekeeping.

1. **Assess the work type** ‚Äî does this add features, fix bugs, change APIs? Or is it cleanup, refactoring, dead code removal?
2. **Break down the work** into small, atomic steps
3. **Identify files** to create and modify
4. **If TDD applies**: identify tests to write (unit + integration), order tests BEFORE implementation
5. **If TDD does not apply**: list the changes and the verification steps (typecheck, existing tests)
6. **Note risks** or potential issues
7. **Write the plan** to {props.planFilePath}

## Does TDD Apply?

**TDD applies** when the work changes observable behavior:
- New features, public API surface, or code paths
- Bug fixes (test reproduces the bug first)
- Changed inputs, outputs, or error handling

**TDD does not apply** when the work is mechanical:
- Dead code removal, unused exports, deprecated aliases
- Renaming, moving, reorganizing without behavior change
- Mechanical refactoring (extract function, change visibility)
- Work where the compiler already enforces correctness

{props.tddPatterns && props.tddPatterns.length > 0
  ? props.tddPatterns.map(p => `${p}`).join('\n\n')
  : ''}

## Plan File Contents

- Overview of the approach
- **Whether TDD applies**, with justification
- Step-by-step changes (TDD: tests before implementation; non-TDD: changes then verification)
- Files to create/modify (with specific function signatures)
- Tests to write (if TDD) or existing tests that cover the change (if non-TDD)
- Risks and mitigations
- How to verify against acceptance criteria

## Commit

After writing the plan file:
1. {`jj describe -m "${props.commitPrefix || "üìù"} docs(unit): create plan for ${props.unitId}"`}
2. `jj new`
3. {`jj bookmark set ${props.branchPrefix || "unit/"}${props.unitId} -r @`}
4. {`jj git push --bookmark ${props.branchPrefix || "unit/"}${props.unitId}`}
