TESTING PHASE ‚Äî Unit: {props.unitId}

Title: {props.unitName}
Category: {props.unitCategory}

{props.whatWasDone ? `\n## What was implemented\n${props.whatWasDone}` : ''}
{props.filesCreated && props.filesCreated.length > 0 ? `\nFiles created: ${props.filesCreated.map(f => `- ${f}`).join('\n')}` : ''}
{props.filesModified && props.filesModified.length > 0 ? `\nFiles modified: ${props.filesModified.map(f => `- ${f}`).join('\n')}` : ''}

Run ALL of the following test categories and report results:

{props.testSuites && props.testSuites.length > 0
  ? props.testSuites.map((suite, i) => `## ${i + 1}. ${suite.name}\nRun: \`${suite.command}\`\n${suite.description}\n${suite.skipCondition ? `If ${suite.skipCondition}, note "${suite.skipNote || 'N/A'}".` : ''}`).join('\n\n')
  : '## Run all test suites\nExecute all relevant test commands for this project.'}

## TDD Verification
- Check that test files exist for new code
- Check that integration tests exist for new user-facing features
- If tests were written AFTER implementation (not TDD), flag as an issue

If any tests fail and you need to fix code to make them pass, commit each fix atomically:
- `jj describe -m "{props.fixCommitPrefix || 'üêõ fix'}(SCOPE): what was fixed"`
- `jj new`
- After fixing: {`jj bookmark set ${props.branchPrefix || "unit/"}${props.unitId} -r @`} && {`jj git push --bookmark ${props.branchPrefix || "unit/"}${props.unitId}`}

Report each category: passed or failed with details.
